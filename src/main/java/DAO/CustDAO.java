package DAO;

import Helper.CustomerByCountry;
import Helper.JDBC;
import Model.Customer;
import Model.FirstLevelDivisions;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.scene.control.Alert;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.sql.SQLException;

/**
 * CustDAO class manages the Appointment methods used to interact with the database.
 */
public class CustDAO {

    /**
     * An Observable list is populated with all the customers from the database by performing a SQL query.
     * @return allCustomers all appointments.
     */
    public static ObservableList<Customer> getEveryCust() {
        ObservableList<Customer> everyCust = FXCollections.observableArrayList();
        try {
            String select = "SELECT Customer_ID, Customer_Name, Address,Postal_Code,Phone,customers.Division_ID, Division\n" + "FROM customers\n" + "JOIN first_level_divisions ON customers.Division_ID = first_level_divisions.Division_ID;";
            PreparedStatement statement = JDBC.getConnection().prepareStatement(select);
            ResultSet resultset = statement.executeQuery();
            while (resultset.next()) {
                int cust_ID = resultset.getInt("Customer_ID");
                String custName = resultset.getString("Customer_Name");
                String custAdd = resultset.getString("Address");
                String custPostalCode = resultset.getString("Postal_Code");
                String custPhone = resultset.getString("Phone");
                int custDiv_ID = resultset.getInt("Division_ID");
                FirstLevelDivisions fldiv = FirstLevelDivisionsDAO.getFirstLevelDivUsingID(custDiv_ID);
                Customer newCust = new Customer(cust_ID, custName, custAdd, custPostalCode, custPhone, custDiv_ID, fldiv);
                everyCust.add(newCust);
            }
            // SQLException catch used in case an error occurs when accessing the database.
        } catch (SQLException exception) {
            System.out.println("Error: " + exception.getMessage());
        }
        return everyCust;
    }

    /**
     * Method that adds a new Customer to Customer in the database using a SQL insert statement.
     *
     * @param newCust user selects the save button in the add customer scene.
     * @throws SQLException if an error occurs when accessing the database.
     * @return addedRows if customer is able to be successfully added.
     */
    public static boolean addCust(Customer newCust) throws SQLException {
        String insert = "INSERT INTO customers (Customer_Name, Address, Postal_Code, Phone, Create_Date, Created_By, Last_Update, Last_Updated_By, Division_ID) VALUES (?,?,?,?, NOW(), USER(), NOW(), USER(), ?)";
        PreparedStatement preparedstatement = JDBC.getConnection().prepareStatement(insert);
        preparedstatement.setString(1, newCust.getName());
        preparedstatement.setString(2, newCust.getAddress());
        preparedstatement.setString(3, newCust.getPostalCode());
        preparedstatement.setString(4, newCust.getPhone());
        preparedstatement.setInt(5, newCust.getDivisionID());
        int addedRows = preparedstatement.executeUpdate();
        return addedRows > 0;
    }

    /**
     * Get the highest (maximum) customer ID from the database. When adding a new customer, the
     * customer ID is generated by getting the highest customer ID and adding 1 to it.
     *
     * @throws SQLException if an error occurs when accessing the database.
     * @return highesCustId the highest (maximum) customer ID.
     */
    public static int getHighestCustId() throws SQLException {
        int highestCustId = 0;
        try {
            String select = "SELECT MAX(Customer_ID) AS Max_ID FROM customers";
            PreparedStatement ps = JDBC.getConnection().prepareStatement(select);
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                highestCustId = rs.getInt("Max_ID");
            }
            // SQLException catch used in case an error occurs when accessing the database.
        } catch (SQLException exception) {
            exception.printStackTrace();
        }
        return highestCustId;
    }

    /**
     * Method that modifies/updates an existing customer's information by performing a SQL Update
     * to the database.
     *
     * @param updateCust user selects the save button in the modify customer scene.
     * @throws SQLException if an error occurs when accessing the database.
     * @return modifiedRows if customer was able to be successfully modified.
     */
    public static boolean modifyCust(Customer updateCust) throws SQLException {
        String update = "UPDATE customers SET Customer_Name = ?, Address = ?, Postal_Code = ?, Phone = ?, Last_Update = NOW(), Last_Updated_By = USER(), Division_ID = ? WHERE Customer_ID = ?";
        PreparedStatement pstate = JDBC.getConnection().prepareStatement(update);
        pstate.setString(1, updateCust.getName());
        pstate.setString(2, updateCust.getAddress());
        pstate.setString(3, updateCust.getPostalCode());
        pstate.setString(4, updateCust.getPhone());
        pstate.setInt(5, updateCust.getDivisionID());
        pstate.setInt(6, updateCust.getId());
        int modifiedRows = pstate.executeUpdate();
        return modifiedRows > 0;
    }

    /**
     * Delete customer in the database by Customer ID. First, it is checked to see if the customer
     * selected to be deleted has any existing appointments. If they do the user will receive an
     * error message advising that the customer's appointments must be removed before the customer
     * can be deleted. If customer does not have any appointments and is able to be successfully
     * deleted, the user receives an information alert.
     *
     * @throws SQLException if an error occurs when accessing the database.
     * @return removedRows if customer is successfully deleted.
     */
    public static boolean removeCust(int customerId) throws SQLException {
        boolean custAppts = reviewAppts(customerId);
        if (custAppts) {
            // If customer has appointments, then user will receive an error message advising
            // that the appointments must be removed before customer can be deleted.
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Error!");
            alert.setHeaderText("Unable to delete.");
            alert.setContentText("Customer's appointments must be removed first\nbefore customer is able to be deleted.");
            alert.showAndWait();
            return false;
        } else {
            String delete = "DELETE FROM customers WHERE Customer_ID = ?";
            PreparedStatement preparedst = JDBC.getConnection().prepareStatement(delete);
            preparedst.setInt(1, customerId);
            int removedRows = preparedst.executeUpdate();
            // If customer was successfully deleted, the user will receive a confirmation message.
            Alert alert = new Alert(Alert.AlertType.INFORMATION);
            alert.setTitle("Information");
            alert.setHeaderText("Customer was able to be deleted.");
            alert.setContentText("Customer was successfully deleted.");
            alert.showAndWait();
            return removedRows > 0;
        }
    }

    /**
     * Used when deleting a customer, a customer's Customer ID is used to check the database to
     * see if they have any existing appointments.
     *
     * @throws SQLException if an error occurs when accessing the database.
     * @return numberAppts if customer has appointments.
     */
    private static boolean reviewAppts(int customerId) throws SQLException {
        String select = "SELECT COUNT(*) AS count FROM appointments WHERE Customer_ID = ?";
        PreparedStatement state = JDBC.getConnection().prepareStatement(select);
        state.setInt(1, customerId);
        ResultSet rs = state.executeQuery();
        rs.next();
        int numberAppts = rs.getInt("count");
        return numberAppts > 0;
    }

    /**
     * Get customer by customer ID from database using a SQL Select statement.
     *
     * @throws SQLException if an error occurs when accessing the database.
     * @return new customer successfully found by customer ID.
     * @return null customer was not found by customer ID.
     */
    public static Customer getCustUsingCustID(int customerID) throws SQLException {
        String select = "SELECT * FROM customers WHERE Customer_ID = ?";
        PreparedStatement prepared = JDBC.getConnection().prepareStatement(select);
        prepared.setInt(1, customerID);
        ResultSet result = prepared.executeQuery();
        if (result.next()) {
            int customer_Id = result.getInt("Customer_ID");
            String customerName = result.getString("Customer_Name");
            String customerAdd = result.getString("Address");
            String customerPostal = result.getString("Postal_Code");
            String customerPhone = result.getString("Phone");
            int firstleveldiv_Id = result.getInt("Division_ID");
            FirstLevelDivisions FLDiv = FirstLevelDivisionsDAO.getFirstLevelDivUsingID(firstleveldiv_Id);
            return new Customer(customer_Id, customerName, customerAdd, customerPostal, customerPhone, firstleveldiv_Id, FLDiv);
        }
        return null;
    }

    /**
     * Used by the Customer by Country report, the number of customers for each country is found by
     * performing SQL statements with the database.
     *
     * @throws SQLException if an error occurs when accessing the database.
     * @return customersbycountry the number of customers by country.
     */
    public List<CustomerByCountry> getCustomersByCountry() throws SQLException {
        Connection cn = JDBC.getConnection();
        List<CustomerByCountry> customersbycountry = new ArrayList<>();
        String query = "SELECT countries.country, COUNT(customers.customer_ID) as customer_count " + "FROM customers " + "JOIN first_level_divisions ON customers.division_ID = first_level_divisions.division_ID " + "JOIN countries ON first_level_divisions.country_ID = countries.country_ID " + "GROUP BY countries.country " + "ORDER BY customer_count ASC";
        try (Statement statement = cn.createStatement();
             ResultSet results = statement.executeQuery(query)) {
            while (results.next()) {
                String countryName = results.getString("country");
                int numberofCusts = results.getInt("customer_count");
                CustomerByCountry info = new CustomerByCountry(countryName, numberofCusts);
                customersbycountry.add(info);
            }
        }
        return customersbycountry;
    }
}

